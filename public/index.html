<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL Monitor Dashboard</title>
    <meta name="description" content="Real-time URL monitoring dashboard with response times and status tracking">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><text y='20' font-size='20'>üìä</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .header h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .header p {
            color: #666;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        .nav-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .nav-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .refresh-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card h3 {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #333;
        }

        .success { color: #28a745; }
        .warning { color: #ffc107; }
        .danger { color: #dc3545; }
        .info { color: #17a2b8; }

        .charts-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }

        .chart-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .chart-card h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .chart-container {
            position: relative;
            height: 400px;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            color: #666;
            font-size: 1.1rem;
        }

        .groups-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .group-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .group-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(31, 38, 135, 0.4);
        }

        .group-card h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .group-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            text-align: center;
        }

        .group-stat {
            padding: 10px;
        }

        .group-stat-label {
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .group-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 5px;
        }

        .back-btn {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .nav-buttons {
                justify-content: center;
            }
            
            .groups-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç URL Monitor Dashboard</h1>
            <p>Real-time monitoring of website availability and performance</p>
            <div class="nav-buttons">
                <button class="nav-btn refresh-btn" onclick="refreshData()">üîÑ Refresh Data</button>
                <a href="failed-requests.html" class="nav-btn" style="text-decoration: none; display: inline-block;">üö® Failed Requests</a>
                <select id="timeRangeSelector" class="nav-btn" style="background: linear-gradient(45deg, #ff6b6b, #ee5a6f); border: none; color: white;" onchange="changeTimeRange()">
                    <option value="1">‚è∞ Last 1 Hour</option>
                    <option value="6">‚è∞ Last 6 Hours</option>
                    <option value="12">‚è∞ Last 12 Hours</option>
                    <option value="24" selected>‚è∞ Last 24 Hours</option>
                    <option value="48">‚è∞ Last 48 Hours</option>
                    <option value="72">‚è∞ Last 3 Days</option>
                    <option value="168">‚è∞ Last 7 Days</option>
                </select>
                <span id="modeIndicator" class="nav-btn" style="background: linear-gradient(45deg, #17a2b8, #20c997); cursor: default;">
                    üì° Detecting mode...
                </span>
                <span id="lastUpdated" class="nav-btn" style="background: linear-gradient(45deg, #6c757d, #495057); cursor: default;">
                    üïí Loading...
                </span>
            </div>
        </div>

        <div id="groupsContainer" class="groups-grid">
            <div class="loading">Loading group statistics...</div>
        </div>

        <div id="urlDetailsContainer" style="display: none;">
            <button class="back-btn" onclick="showGroups()">‚¨ÖÔ∏è Back to Groups</button>
            <h3 id="selectedGroupTitle">Group Details</h3>
            <div id="urlsList" class="stats-grid"></div>
        </div>

        <div class="charts-container">
            <div class="chart-card">
                <h3>üìä Response Times by Group (Last 24 Hours)</h3>
                <div class="chart-container">
                    <canvas id="responseTimeChart"></canvas>
                </div>
            </div>

            <div class="chart-card">
                <h3>üö¶ Status Code Distribution (Last 24 Hours)</h3>
                <div class="chart-container">
                    <canvas id="statusCodeChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        let responseTimeChart;
        let statusCodeChart;
        let currentView = 'groups'; // 'groups' or 'urls'
        let selectedGroup = null;
        let timeRangeHours = 24; // Default 24 hours, configurable

        // Detect if we're running in static mode (GitHub Pages) or with live API
        const isStaticMode = window.location.hostname.includes('github.io') || 
                           window.location.protocol === 'file:';

        console.log('Static mode detected:', isStaticMode, 'hostname:', window.location.hostname, 'protocol:', window.location.protocol, 'port:', window.location.port);

        function updateTimestamp() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            const dateString = now.toLocaleDateString('en-US', { 
                month: 'short', 
                day: '2-digit' 
            });
            document.getElementById('lastUpdated').innerHTML = `üïí Updated: ${dateString} ${timeString}`;
        }

        async function fetchWithFallback(apiPath, staticFile) {
            try {
                console.log('fetchWithFallback: called with apiPath:', apiPath, 'staticFile:', staticFile, 'isStaticMode:', isStaticMode);
                // Try live API first
                if (!isStaticMode) {
                    console.log('fetchWithFallback: trying live API...');
                    const response = await fetch(apiPath);
                    console.log('fetchWithFallback: live API response:', response.status, response.ok);
                    if (response.ok) {
                        const data = await response.json();
                        console.log('fetchWithFallback: live API data:', data);
                        return data;
                    }
                }
                
                // Fallback to static JSON file with cache busting
                // Note: Static files don't support query parameters, so we just fetch the base file
                console.log('fetchWithFallback: falling back to static file...');
                const cacheBuster = Date.now();
                const response = await fetch(`${staticFile}?v=${cacheBuster}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Fetched from static file:', staticFile, 'records:', data.length);
                    return data;
                }
                
                console.log('fetchWithFallback: no data available, returning empty array');
                return [];
            } catch (error) {
                console.error(`Error fetching data from ${apiPath} or ${staticFile}:`, error);
                return [];
            }
        }

        async function fetchGroups() {
            return await fetchWithFallback('/api/groups', './api/groups.json');
        }

        async function fetchUrlsByGroup(groupName) {
            try {
                // Get all results data and extract URLs for this group
                const results = await fetchResults('-24 hours'); // This will now handle static mode properly
                
                console.log('fetchUrlsByGroup - Total results:', results.length, 'for group:', groupName);
                
                // Filter results by group and calculate stats per URL
                const groupUrls = new Map();
                
                results.forEach(result => {
                    let resultGroup = 'Other';
                    if (result.name.includes('Max') || result.url.includes('max.com')) {
                        resultGroup = 'Max Streaming';
                    } else if (result.name.includes('D+') || result.name.includes('Discovery') || result.url.includes('discoveryplus')) {
                        resultGroup = 'Discovery Plus';
                    }
                    
                    if (resultGroup === groupName) {
                        const urlKey = result.url;
                        if (!groupUrls.has(urlKey)) {
                            groupUrls.set(urlKey, {
                                name: result.name,
                                url: result.url,
                                total_requests: 0,
                                successful_requests: 0,
                                total_response_time: 0,
                                success_rate: 0,
                                avg_response_time: 0
                            });
                        }
                        
                        const urlStats = groupUrls.get(urlKey);
                        urlStats.total_requests++;
                        urlStats.total_response_time += result.responseTime || 0;
                        
                        if (result.success || (result.status >= 200 && result.status < 300)) {
                            urlStats.successful_requests++;
                        }
                    }
                });
                
                // Calculate final stats
                const urlsArray = Array.from(groupUrls.values()).map(url => {
                    url.success_rate = url.total_requests > 0 ? (url.successful_requests / url.total_requests) * 100 : 0;
                    url.avg_response_time = url.total_requests > 0 ? url.total_response_time / url.total_requests : 0;
                    return url;
                });
                
                console.log('fetchUrlsByGroup - URLs found:', urlsArray.length, urlsArray);
                return urlsArray;
            } catch (error) {
                console.error('Error fetching URLs by group:', error);
                return [];
            }
        }

        async function fetchStatusCodes(timeRange = '-24 hours', groupName = null) {
            let apiUrl = `/api/status-codes?timeRange=${encodeURIComponent(timeRange)}`;
            if (groupName) {
                apiUrl += `&group=${encodeURIComponent(groupName)}`;
            }
            return await fetchWithFallback(apiUrl, './api/status-codes.json');
        }

        async function fetchResults(timeRange = '-24 hours', groupName = null) {
            try {
                let results;
                
                if (isStaticMode) {
                    // In static mode, fetch all data and filter client-side
                    console.log('Static mode: fetching all results and filtering client-side');
                    const cacheBuster = Date.now();
                    const response = await fetch(`./api/results.json?v=${cacheBuster}`);
                    if (response.ok) {
                        const allResults = await response.json();
                        console.log('Static mode: fetched', allResults.length, 'total results');
                        
                        // Filter by time range client-side using configurable hours
                        const now = new Date();
                        const timeFilterMs = timeRangeHours * 60 * 60 * 1000; // Convert hours to milliseconds
                        const cutoffTime = new Date(now.getTime() - timeFilterMs);
                        
                        results = allResults.filter(result => {
                            const resultTime = new Date(result.timestamp);
                            return resultTime >= cutoffTime;
                        });
                        
                        console.log('Static mode: filtered to', results.length, 'results within last', timeRangeHours, 'hours');
                    } else {
                        console.log('Static mode: no results.json file found');
                        results = [];
                    }
                } else {
                    // In live mode, use server-side filtering
                    let apiUrl = `/api/results?timeRange=${encodeURIComponent(timeRange)}`;
                    if (groupName) {
                        apiUrl += `&group=${encodeURIComponent(groupName)}`;
                    }
                    console.log('Live mode: fetching from', apiUrl);
                    const response = await fetch(apiUrl);
                    if (response.ok) {
                        results = await response.json();
                    } else {
                        results = [];
                    }
                }
                
                console.log('fetchResults returned:', results.length, 'results for timeRange:', timeRange, 'groupName:', groupName);
                return results;
            } catch (error) {
                console.error('Error in fetchResults:', error);
                return [];
            }
        }

        function getStatusColor(status) {
            if (status >= 200 && status < 300) return '#28a745'; // Success - Green
            if (status >= 300 && status < 400) return '#ffc107'; // Redirect - Yellow
            if (status >= 400 && status < 500) return '#fd7e14'; // Client Error - Orange
            if (status >= 500) return '#dc3545'; // Server Error - Red
            return '#6c757d'; // Unknown - Gray
        }

        function getStatusText(status) {
            if (status >= 200 && status < 300) return 'Success';
            if (status >= 300 && status < 400) return 'Redirect';
            if (status >= 400 && status < 500) return 'Client Error';
            if (status >= 500) return 'Server Error';
            return 'Unknown';
        }

        function renderGroups(groups) {
            const container = document.getElementById('groupsContainer');
            
            if (groups.length === 0) {
                container.innerHTML = '<div class="loading">No groups available yet. Monitoring will begin shortly...</div>';
                return;
            }

            container.innerHTML = groups.map(group => {
                let successClass;
                if (group.success_rate >= 95) {
                    successClass = 'success';
                } else if (group.success_rate >= 80) {
                    successClass = 'warning';
                } else {
                    successClass = 'danger';
                }
                
                return `
                    <div class="stat-card" style="cursor: pointer;" onclick="showGroupUrls('${group.group_name}')">
                        <h3>${group.group_name}</h3>
                        <div class="stat-value ${successClass}">${group.success_rate.toFixed(1)}%</div>
                        <small>Success Rate</small>
                        <hr style="margin: 10px 0;">
                        <div class="stat-value">${Math.round(group.avg_response_time)}ms</div>
                        <small>Avg Response Time</small>
                        <hr style="margin: 10px 0;">
                        <div class="stat-value">${group.url_count}</div>
                        <small>URLs in Group</small>
                        <hr style="margin: 10px 0;">
                        <div class="stat-value">${group.total_requests}</div>
                        <small>Total Requests</small>
                    </div>
                `;
            }).join('');
        }

        async function showGroupUrls(groupName) {
            currentView = 'urls';
            selectedGroup = groupName;
            document.getElementById('groupsContainer').style.display = 'none';
            document.getElementById('urlDetailsContainer').style.display = 'block';
            document.getElementById('selectedGroupTitle').textContent = `URLs in ${groupName}`;

            const urls = await fetchUrlsByGroup(groupName);
            const container = document.getElementById('urlsList');

            if (urls.length === 0) {
                container.innerHTML = '<div class="loading">No URLs found in this group.</div>';
                return;
            }

            container.innerHTML = urls.map(url => {
                let successClass;
                if (url.success_rate >= 95) {
                    successClass = 'success';
                } else if (url.success_rate >= 80) {
                    successClass = 'warning';
                } else {
                    successClass = 'danger';
                }
                
                return `
                    <div class="stat-card">
                        <h3>${url.name}</h3>
                        <small style="color: #666; font-size: 12px;">${url.url}</small>
                        <hr style="margin: 10px 0;">
                        <div class="stat-value ${successClass}">${url.success_rate.toFixed(1)}%</div>
                        <small>Success Rate</small>
                        <hr style="margin: 10px 0;">
                        <div class="stat-value">${Math.round(url.avg_response_time)}ms</div>
                        <small>Avg Response Time</small>
                        <hr style="margin: 10px 0;">
                        <div class="stat-value">${url.total_requests}</div>
                        <small>Total Requests</small>
                    </div>
                `;
            }).join('');

            // Update charts to show only this group's data
            await createResponseTimeChart();
            await createStatusCodeChart();
        }

        function showGroups() {
            currentView = 'groups';
            selectedGroup = null;
            document.getElementById('groupsContainer').style.display = 'grid';
            document.getElementById('urlDetailsContainer').style.display = 'none';
            
            // Update charts to show all URLs
            createResponseTimeChart();
            createStatusCodeChart();
        }

        function changeTimeRange() {
            const selector = document.getElementById('timeRangeSelector');
            timeRangeHours = parseInt(selector.value);
            console.log('Time range changed to:', timeRangeHours, 'hours');
            
            // Update chart titles
            const responseChartTitle = document.querySelector('.charts-container .chart-card:first-child h3');
            const statusChartTitle = document.querySelector('.charts-container .chart-card:last-child h3');
            
            // Simple time text mapping
            const timeTextMap = {
                1: '1 Hour',
                6: '6 Hours', 
                12: '12 Hours',
                24: '24 Hours',
                48: '48 Hours',
                72: '3 Days',
                168: '7 Days'
            };
            const timeText = timeTextMap[timeRangeHours] || `${timeRangeHours} Hours`;
            
            responseChartTitle.textContent = `üìä Response Times by Group (Last ${timeText})`;
            statusChartTitle.textContent = `üö¶ Status Code Distribution (Last ${timeText})`;
            
            // Refresh all data with new time range
            refreshData();
        }

        async function createResponseTimeChart() {
            console.log('Creating response time chart...');
            const ctx = document.getElementById('responseTimeChart').getContext('2d');
            const results = await fetchResults('-24 hours', selectedGroup);
            
            console.log('Results fetched:', results.length, 'records', 'for group:', selectedGroup);
            
            if (responseTimeChart) {
                responseTimeChart.destroy();
            }

            if (results.length === 0) {
                console.log('No data available for chart');
                ctx.fillText('No data available', 10, 50);
                return;
            }

            const groupedData = {};
            results.forEach(result => {
                // Ensure we have valid data
                if (!result.name || !result.timestamp || result.responseTime === undefined) {
                    console.warn('Skipping invalid result:', result);
                    return;
                }
                
                // Filter by group if a group is selected
                if (selectedGroup) {
                    let resultGroup = 'Other';
                    if (result.name.includes('Max') || result.url.includes('max.com')) {
                        resultGroup = 'Max Streaming';
                    } else if (result.name.includes('D+') || result.name.includes('Discovery') || result.url.includes('discoveryplus')) {
                        resultGroup = 'Discovery Plus';
                    }
                    
                    if (resultGroup !== selectedGroup) {
                        return; // Skip results not in selected group
                    }
                }
                
                if (!groupedData[result.name]) {
                    groupedData[result.name] = [];
                }
                
                // Ensure timestamp is a valid date
                const timestamp = new Date(result.timestamp);
                if (isNaN(timestamp.getTime())) {
                    console.warn('Invalid timestamp:', result.timestamp);
                    return;
                }
                
                groupedData[result.name].push({
                    x: timestamp,
                    y: result.responseTime || 0
                });
            });

            console.log('Grouped data:', Object.keys(groupedData), 'datasets found');

            const datasets = Object.keys(groupedData).map((name, index) => ({
                label: name,
                data: groupedData[name],
                borderColor: `hsl(${index * 60}, 70%, 50%)`,
                backgroundColor: `hsla(${index * 60}, 70%, 50%, 0.1)`,
                tension: 0.4,
                pointRadius: 3,
                pointHoverRadius: 6
            }));

            console.log('Creating chart with datasets:', datasets.length, 'datasets');

            try {
                responseTimeChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'hour',
                                    displayFormats: {
                                        hour: 'MMM dd HH:mm'
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Response Time (ms)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top'
                            },
                            title: {
                                display: true,
                                text: selectedGroup ? `Response Time - ${selectedGroup}` : 'Response Time - All URLs'
                            }
                        }
                    }
                });
                console.log('Response time chart created successfully');
            } catch (error) {
                console.error('Error creating response time chart:', error);
                ctx.fillText('Chart creation failed: ' + error.message, 10, 50);
            }
        }

        async function createStatusCodeChart() {
            console.log('Creating status code chart...');
            const ctx = document.getElementById('statusCodeChart').getContext('2d');
            const results = await fetchResults('-24 hours', selectedGroup);
            
            console.log('Status chart - Results fetched:', results.length, 'records', 'for group:', selectedGroup);
            
            if (statusCodeChart) {
                statusCodeChart.destroy();
            }
            
            if (results.length === 0) {
                console.log('No data available for status chart');
                ctx.fillText('No data available', 10, 50);
                return;
            }

            // Group by URL and organize status codes over time
            const groupedData = {};
            results.forEach(result => {
                // Ensure we have valid data
                if (!result.name || !result.timestamp || result.status === undefined) {
                    console.warn('Skipping invalid result for status chart:', result);
                    return;
                }
                
                // Filter by group if a group is selected
                if (selectedGroup) {
                    let resultGroup = 'Other';
                    if (result.name.includes('Max') || result.url.includes('max.com')) {
                        resultGroup = 'Max Streaming';
                    } else if (result.name.includes('D+') || result.name.includes('Discovery') || result.url.includes('discoveryplus')) {
                        resultGroup = 'Discovery Plus';
                    }
                    
                    if (resultGroup !== selectedGroup) {
                        return; // Skip results not in selected group
                    }
                }
                
                if (!groupedData[result.name]) {
                    groupedData[result.name] = [];
                }
                
                // Ensure timestamp is a valid date
                const timestamp = new Date(result.timestamp);
                if (isNaN(timestamp.getTime())) {
                    console.warn('Invalid timestamp in status chart:', result.timestamp);
                    return;
                }
                
                groupedData[result.name].push({
                    x: timestamp,
                    y: result.status || 0
                });
            });

            // Sort each group by timestamp
            Object.keys(groupedData).forEach(name => {
                groupedData[name].sort((a, b) => a.x - b.x);
            });

            console.log('Status chart - Grouped data:', Object.keys(groupedData), 'datasets found');

            const datasets = Object.keys(groupedData).map((name, index) => ({
                label: name,
                data: groupedData[name],
                borderColor: `hsl(${index * 60}, 70%, 50%)`,
                backgroundColor: `hsla(${index * 60}, 70%, 50%, 0.1)`,
                tension: 0.1,
                fill: false,
                pointBackgroundColor: function(context) {
                    const status = context.parsed ? context.parsed.y : 0;
                    return getStatusColor(status);
                },
                pointBorderColor: function(context) {
                    const status = context.parsed ? context.parsed.y : 0;
                    return getStatusColor(status);
                },
                pointRadius: 4,
                pointHoverRadius: 6
            }));

            try {
                statusCodeChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'hour',
                                    displayFormats: {
                                        hour: 'MMM dd HH:mm'
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'HTTP Status Code'
                                },
                                min: 0,
                                max: 600,
                                ticks: {
                                    stepSize: 100,
                                    callback: function(value) {
                                        // Show major status code ranges
                                        if (value === 0) return '0 (Failed)';
                                        if (value === 200) return '200 (Success)';
                                        if (value === 300) return '300 (Redirect)';
                                        if (value === 400) return '400 (Client Error)';
                                        if (value === 500) return '500 (Server Error)';
                                        return value;
                                    }
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: selectedGroup ? `Status Codes Over Time - ${selectedGroup}` : 'Status Codes Over Time - All URLs'
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const status = context.parsed ? context.parsed.y : 0;
                                        return `${context.dataset.label}: ${status} (${getStatusText(status)})`;
                                    }
                                }
                            }
                        }
                    }
                });
                console.log('Status code chart created successfully');
            } catch (error) {
                console.error('Error creating status code chart:', error);
                ctx.fillText('Chart creation failed: ' + error.message, 10, 50);
            }
        }

        async function refreshData() {
            try {
                updateTimestamp();
                if (currentView === 'groups') {
                    const groups = await fetchGroups();
                    renderGroups(groups);
                    selectedGroup = null;
                } else if (selectedGroup) {
                    // In URL details view, refresh that view
                    await showGroupUrls(selectedGroup);
                    return; // showGroupUrls already updates the charts
                }
                
                // Refresh charts with current group filter
                await createResponseTimeChart();
                await createStatusCodeChart();
            } catch (error) {
                console.error('Error refreshing data:', error);
            }
        }

        // Initial load
        async function initialize() {
            // Update mode indicator
            const modeIndicator = document.getElementById('modeIndicator');
            if (isStaticMode) {
                modeIndicator.innerHTML = 'üåê Static Mode (GitHub Pages)';
                modeIndicator.style.background = 'linear-gradient(45deg, #6f42c1, #e83e8c)';
                modeIndicator.title = 'Running on GitHub Pages with data refreshed every 15 minutes';
            } else {
                modeIndicator.innerHTML = '‚ö° Live Mode';
                modeIndicator.style.background = 'linear-gradient(45deg, #28a745, #20c997)';
                modeIndicator.title = 'Connected to live API with real-time data';
            }

            updateTimestamp();
            console.log('Initialize: Starting to fetch groups...');
            const groups = await fetchGroups();
            console.log('Initialize: Fetched groups:', groups);
            renderGroups(groups);
            await createResponseTimeChart();
            await createStatusCodeChart();
        }

        initialize();

        // Auto-refresh every 30 seconds (more frequently in live mode)
        const refreshInterval = isStaticMode ? 60000 : 30000; // 1 min for static, 30s for live
        setInterval(refreshData, refreshInterval);
    </script>
</body>
</html>
