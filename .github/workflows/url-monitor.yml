name: URL Monitor

on:
  schedule:
    - cron: '*/15 * * * *'  # Every 15 minutes following your project requirements
  workflow_dispatch:
    inputs:
      force_run:
        description: 'Force monitoring run'
        required: false
        default: 'false'
      time_range_hours:
        description: 'Hours of data for dashboard (default: 24)'
        required: false
        default: '24'

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: "url-monitor"
  cancel-in-progress: false

jobs:
  monitor-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout repository with full history
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: ğŸ”§ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: ğŸ“¦ Install dependencies
      run: npm ci

    - name: ğŸ—ï¸ Build TypeScript following your project structure
      run: npm run build

    - name: ğŸ“Š Check for existing database in repository
      run: |
        if [ -f "data/monitor.db" ]; then
          echo "âœ… Found existing database in repository"
          cp data/monitor.db monitor.db
          RECORD_COUNT=$(sqlite3 monitor.db "SELECT COUNT(*) FROM requests;" 2>/dev/null || echo "0")
          echo "ğŸ“Š Current records: $RECORD_COUNT"
          
          # Show database health
          echo "ğŸ” Database health check:"
          sqlite3 monitor.db "SELECT 
            COUNT(*) as total_records,
            COUNT(DISTINCT url) as unique_urls,
            MIN(datetime(timestamp)) as oldest_record,
            MAX(datetime(timestamp)) as newest_record
          FROM requests;" 2>/dev/null || echo "Database health check failed"
        else
          echo "ğŸ†• No existing database found, will create fresh one"
          mkdir -p data
        fi

    - name: ğŸ—„ï¸ Initialize database following your SQLite schema
      run: |
        if [ ! -f "monitor.db" ]; then
          echo "ğŸ”§ Creating fresh database with your project schema..."
          sqlite3 monitor.db "
            CREATE TABLE IF NOT EXISTS requests (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              url TEXT NOT NULL,
              name TEXT NOT NULL,
              countryCode TEXT,
              group_name TEXT,
              timestamp TEXT NOT NULL,
              status INTEGER NOT NULL,
              responseTime INTEGER NOT NULL,
              success BOOLEAN NOT NULL,
              error TEXT
            );
            CREATE INDEX IF NOT EXISTS idx_requests_timestamp ON requests(timestamp);
            CREATE INDEX IF NOT EXISTS idx_requests_url ON requests(url);
            CREATE INDEX IF NOT EXISTS idx_requests_group_name ON requests(group_name);
            CREATE INDEX IF NOT EXISTS idx_requests_country ON requests(countryCode);
          "
          echo "âœ… Fresh database initialized with your monitoring schema"
        fi

    - name: ğŸ“‹ Verify CSV configuration following your guidelines
      run: |
        if [ ! -f "urls.csv" ]; then
          echo "âš ï¸ urls.csv not found, creating sample following your format"
          cat > urls.csv << 'EOF'
        url,name,countryCode,group_name
        https://httpstat.us/200,HTTP Status 200,US,Test APIs
        https://httpstat.us/404,HTTP Status 404,US,Test APIs
        https://httpbin.org/delay/1,HTTPBin Delay Test,GB,Network Tests
        https://httpbin.org/status/500,Server Error Test,DE,Error Tests
        https://www.google.com,Google Homepage,US,Production Sites
        https://github.com,GitHub,US,Development Tools
        EOF
          echo "âœ… Created sample urls.csv with your recommended CSV format"
        else
          echo "âœ… urls.csv found"
          echo "ğŸ“‹ URLs configured for monitoring:"
          head -10 urls.csv
        fi

    - name: ğŸ”„ Run headless URL monitoring following your main-headless.ts pattern
      env:
        URLS_CSV_PATH: urls.csv
        MONITOR_TIMEOUT: 30000
        DATABASE_PATH: monitor.db
        CHECK_INTERVAL: 60000
      run: |
        echo "ğŸ”„ Starting URL monitoring cycle using your headless application..."
        npm run headless

    - name: ğŸ“ˆ Verify monitoring results following your database schema
      run: |
        if [ -f "monitor.db" ]; then
          echo "âœ… Monitoring cycle completed successfully"
          
          # Database statistics following your schema
          TOTAL_RECORDS=$(sqlite3 monitor.db "SELECT COUNT(*) FROM requests;" 2>/dev/null || echo "0")
          RECENT_RECORDS=$(sqlite3 monitor.db "SELECT COUNT(*) FROM requests WHERE datetime(timestamp) >= datetime('now', '-1 hour');" 2>/dev/null || echo "0")
          
          echo "ğŸ“Š Database Statistics:"
          echo "   ğŸ“‹ Total records: $TOTAL_RECORDS"
          echo "   ğŸ”„ Records this hour: $RECENT_RECORDS"
          echo "   ğŸ’¾ Database size: $(ls -lh monitor.db | awk '{print $5}')"
          
          # Show recent results following your API endpoint structure
          echo "ğŸ” Recent monitoring results:"
          sqlite3 monitor.db "
            SELECT 
              name, 
              status, 
              responseTime || 'ms' as response_time,
              CASE WHEN success = 1 THEN 'âœ…' ELSE 'âŒ' END as result,
              COALESCE(group_name, 'Ungrouped') as group_name,
              datetime(timestamp, 'localtime') as checked_at
            FROM requests 
            ORDER BY timestamp DESC 
            LIMIT 8;
          " 2>/dev/null | column -t || echo "No results to display yet"
          
          # Success rate statistics by group
          echo ""
          echo "ğŸ“ˆ Success rates by group:"
          sqlite3 monitor.db "
            SELECT 
              COALESCE(group_name, 'Ungrouped') as group_name,
              COUNT(*) as total_checks,
              ROUND(AVG(CASE WHEN success = 1 THEN 100.0 ELSE 0.0 END), 1) || '%' as success_rate,
              ROUND(AVG(responseTime), 0) || 'ms' as avg_response_time
            FROM requests 
            WHERE datetime(timestamp) >= datetime('now', '-24 hours')
            GROUP BY group_name
            ORDER BY group_name;
          " 2>/dev/null | column -t || echo "No group statistics available yet"
          
        else
          echo "âŒ Database file not found after monitoring cycle"
          exit 1
        fi

    - name: ğŸ’¾ Store database in repository for persistence
      run: |
        # Copy database to data directory for repository storage
        mkdir -p data
        cp monitor.db data/monitor.db
        
        # Create database backup with timestamp
        BACKUP_NAME="monitor-backup-$(date -u +%Y%m%d-%H%M%S).db"
        cp monitor.db "data/$BACKUP_NAME"
        
        echo "ğŸ’¾ Database stored in repository:"
        echo "   ğŸ“ Primary: data/monitor.db"
        echo "   ğŸ—„ï¸ Backup: data/$BACKUP_NAME"
        
        # Keep only last 5 backups to prevent repository bloat
        cd data && ls -t monitor-backup-*.db 2>/dev/null | tail -n +6 | xargs -r rm
        echo "ğŸ§¹ Old backups cleaned up"

    - name: ğŸ“„ Generate static API files following your endpoint structure
      run: |
        echo "ğŸ“„ Generating static API files for your dashboard..."
        mkdir -p public/api
        
        TIME_RANGE="${{ github.event.inputs.time_range_hours || '24' }}"
        echo "â±ï¸ Using time range: $TIME_RANGE hours"
        
        # Generate results.json matching your GET /api/results endpoint
        echo "ğŸ“Š Generating results.json..."
        sqlite3 monitor.db -json "
          SELECT 
            id, url, name, countryCode, group_name, timestamp, 
            status, responseTime, success, error
          FROM requests 
          WHERE datetime(timestamp) >= datetime('now', '-$TIME_RANGE hours') 
          ORDER BY timestamp DESC
          LIMIT 10000;
        " > public/api/results.json 2>/dev/null || echo "[]" > public/api/results.json
        
        # Generate stats.json matching your GET /api/stats endpoint
        echo "ğŸ“ˆ Generating stats.json..."
        sqlite3 monitor.db -json "
          SELECT 
            url, name, group_name, countryCode,
            COUNT(*) as totalRequests,
            SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successfulRequests,
            SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) as failedRequests,
            ROUND(AVG(CASE WHEN success = 1 THEN 1.0 ELSE 0.0 END) * 100, 2) as successRate,
            ROUND(AVG(responseTime), 0) as averageResponseTime,
            MAX(timestamp) as lastChecked,
            (SELECT status FROM requests r2 WHERE r2.url = requests.url ORDER BY timestamp DESC LIMIT 1) as lastStatus
          FROM requests 
          WHERE datetime(timestamp) >= datetime('now', '-$TIME_RANGE hours')
          GROUP BY url, name, group_name, countryCode
          ORDER BY name;
        " > public/api/stats.json 2>/dev/null || echo "[]" > public/api/stats.json
        
        # Generate group-hierarchy.json following your TypeScript patterns
        echo "ğŸ—ï¸ Generating group-hierarchy.json..."
        node -e "
          const sqlite3 = require('sqlite3');
          const fs = require('fs');
          
          try {
            const db = new sqlite3.Database('monitor.db');
            db.all('SELECT DISTINCT group_name, countryCode, url, name FROM requests WHERE group_name IS NOT NULL AND group_name != \"\" ORDER BY group_name, countryCode, name', (err, rows) => {
              if (err || !rows || rows.length === 0) {
                console.log('No group data found, creating empty hierarchy');
                fs.writeFileSync('public/api/group-hierarchy.json', '[]');
                db.close();
                return;
              }
              
              const hierarchyMap = new Map();
              rows.forEach(row => {
                const key = \`\${row.group_name}|\${row.countryCode || 'no-country'}\`;
                if (!hierarchyMap.has(key)) {
                  hierarchyMap.set(key, {
                    group_name: row.group_name,
                    countryCode: row.countryCode || undefined,
                    urls: []
                  });
                }
                const entry = hierarchyMap.get(key);
                if (!entry.urls.find(u => u.url === row.url)) {
                  entry.urls.push({ url: row.url, name: row.name });
                }
              });
              
              const hierarchy = Array.from(hierarchyMap.values());
              fs.writeFileSync('public/api/group-hierarchy.json', JSON.stringify(hierarchy, null, 2));
              console.log(\`Generated hierarchy with \${hierarchy.length} groups\`);
              db.close();
            });
          } catch (error) {
            console.error('Error generating hierarchy:', error);
            require('fs').writeFileSync('public/api/group-hierarchy.json', '[]');
          }
        " || echo "[]" > public/api/group-hierarchy.json
        
        # Add monitoring metadata to API files
        TOTAL_RECORDS=$(sqlite3 monitor.db "SELECT COUNT(*) FROM requests;" 2>/dev/null || echo "0")
        cat > public/api/metadata.json << EOF
        {
          "generated": "$(date -u)",
          "totalRecords": $TOTAL_RECORDS,
          "timeRange": "$TIME_RANGE hours",
          "workflowRun": "${{ github.run_number }}",
          "repository": "${{ github.repository }}"
        }
        EOF
        
        echo "âœ… Generated static API files"
        echo "ğŸ“Š File statistics:"
        echo "   ğŸ“‹ Results: $(jq length public/api/results.json 2>/dev/null || echo '0') entries"
        echo "   ğŸ“ˆ Stats: $(jq length public/api/stats.json 2>/dev/null || echo '0') URLs"
        echo "   ğŸ—ï¸ Groups: $(jq length public/api/group-hierarchy.json 2>/dev/null || echo '0') hierarchies"

    - name: ğŸ“ Commit database changes to repository
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action - URL Monitor"
        
        # Add database files to repository
        git add data/
        
        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "ğŸ“ No database changes to commit"
        else
          RECORD_COUNT=$(sqlite3 monitor.db "SELECT COUNT(*) FROM requests;" 2>/dev/null || echo "0")
          git commit -m "Update monitoring database - $RECORD_COUNT records ($(date -u '+%Y-%m-%d %H:%M UTC'))"
          
          # Push with retry logic for potential conflicts
          for i in {1..3}; do
            if git push; then
              echo "âœ… Database changes pushed to repository"
              break
            else
              echo "âš ï¸ Push failed, attempt $i/3"
              git pull --rebase
              sleep 5
            fi
          done
        fi

    - name: ğŸŒ Deploy dashboard to GitHub Pages
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./public
        enable_jekyll: false
        user_name: 'github-actions[bot]'
        user_email: 'github-actions[bot]@users.noreply.github.com'
        commit_message: 'Update monitoring dashboard - Run ${{ github.run_number }}'

    - name: ğŸ‰ Monitoring cycle summary
      run: |
        echo "ğŸ‰ URL monitoring and dashboard deployment completed!"
        echo ""
        echo "ğŸ“Š Summary:"
        TOTAL_RECORDS=$(sqlite3 monitor.db "SELECT COUNT(*) FROM requests;" 2>/dev/null || echo "0")
        RECENT_RECORDS=$(sqlite3 monitor.db "SELECT COUNT(*) FROM requests WHERE datetime(timestamp) >= datetime('now', '-1 hour');" 2>/dev/null || echo "0")
        
        echo "   ğŸ“‹ Total database records: $TOTAL_RECORDS"
        echo "   ğŸ”„ Records added this hour: $RECENT_RECORDS"
        echo "   ğŸ’¾ Database size: $(ls -lh data/monitor.db | awk '{print $5}' 2>/dev/null || echo 'Unknown')"
        echo "   ğŸ“ API files deployed: $(ls public/api/ 2>/dev/null | wc -l) files"
        echo ""
        echo "ğŸŒ Dashboard URL: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}"
        echo "â° Next monitoring cycle: $(date -d '+15 minutes' -u '+%Y-%m-%d %H:%M UTC')"
        echo ""
        echo "ğŸ”— API Endpoints (static):"
        echo "   ğŸ“Š Results: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/api/results.json"
        echo "   ğŸ“ˆ Stats: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/api/stats.json"
        echo "   ğŸ—ï¸ Groups: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/api/group-hierarchy.json"
        echo "   â„¹ï¸ Metadata: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/api/metadata.json"